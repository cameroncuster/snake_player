April 6:
    * created the repository (csc315_spr2021_snake) and downloaded the startup
      code
    * compiled and ran the startup code
    * made first commit of startup code source with CHANGELOG

April 10:
    * Attempted bfs search, could not get implementation to work smoothly with
      interface
    * fought debugger for extensive amount of time before deciding the bfs was
      not worth it
      Tested: Graphically and with the debugger
      Data Structures: Queue (for bfs), Adjacency List to store the graph
      representation
    * brainstormed ideas extensively for more successful player

April 12:
    * Thinking about new ideas every day and different graph algorithms becuase
      nothing else appears to be valid
    * Use A* for searching because it will perform better than bfs, dfs, etc.
    * Idea: Dijkstra's with dynamic weighting system to prevent the snake from
      taking a path into the tail

April 14:
    * Thought about how anyone scored perfectly in the game using graph traversal
      without using an algorithm which eventually created or approximated a
      Hamaltonian Path

April 15:
    * Idea for genetic algorithm to determine weights for Dijkstra's
      dynamically throughout the search to be marketed as a "graph algorithm"
    * Idea: to use GA through evolution of random paths and evolve the top x(10)
      snakes to populate the next generation

April 17:
    * Idea to loop along self by weighting edges with A* of tail very heavily,
      and if biconnected the then become a scanner until a path becomes available
    * planning to implement one of the last two idea's, maybe both in the next 
      few hours
    * going to implement GA with A* search algorithm in combination, A* tail
      coiling algorithm builds length of the snake while the GA enforces
      survival. With the focus of both algorithms the player must be successful.
    * Working to implement the GA and have been unsuccessful thus far
      Data Structures: Arrays, Sets, and Maps
      Testing: 100 Runs to validate success of the algorithm and performance,
      (Graphical) is used to analyze game play and potential issues
      Visual testing is for the purpose of generating a working implementation
      before the player is tested for performance
    * May upgrade the visual for commandline output so I can examine the moves
      executed by the snake

April 18:
    * Some success with the genetic player as a minimal improvement from the
      previous player, same data structures and algorithms (bug fixes)

      Testing: Testing is still done graphically and with 100 run script to
      evaluate the performance of the algorithm
      Data Structures: Arrays, Sets, Maps

    * Working to expand the GA for multiple generations, current success with one
      generation has been minimal as a brute a single generation GA degenrates to
      a brute force algorithm - with a prune to remove invalid moves
    * GA tracks score, but the length of the snake is not approximated correctly
      because the apples in the simulated games spawn in different locations than
      in actual gameplay so the snake thinks it is shorter/longer than it
      actually is in execution
    * GA is also incredibly slow and is likely to time limit given multiple
      generations
    * Potential Fixes: spawn more apples in the simulation, and count number of
      moves as opposed to score for populating (naturally selecting) the next
      generation
    * Discontinuing the GA, as it will not be the optimal approach to reasons
      listed above.
    * Going to continue to brainstorm approaches. The most fun problems take a
      lot of thought... not necessiarly a lot of code.

      * GA will not successfully run for 100 runs due to generational issues

      *********************
      * Approximate Score *
      * Average: 10-15    *
      * Max Score: 20     *
      * Verified through  *
      * Graphical Runs    *
      * (Imprecise)       *
      *********************


April 20:
    * Began exploring idea for A* where heuristic follows tail of snake
    * As a more descriptive explaination, the A* heurisitic is weighted so that
      nodes adjacent to the tail are preferred. Preferring nodes adjacent to the
      tail will prevent the snake from trapping itself inside it's own tail in
      many situations.
    * Pseudo implementation of the algorithm (described above) performs only
      slightly better than a traditional A* search for the food.
    * Master cleaned and branching implemented for foundational software
      development practices and proper coding standard
    * Working A* player with no heuristic, going to modify the heurisitc to
      follow the tail for as long as possible (e.a. nodes adjacent to the tail
      are weighted very heavily in heuristic function)

      Testing: Visual, 100 run script, Scoreboard
      Data Structures: Priority Queue using (min_heap) for A*, Arrays (dynamic),
      Hashes, RB Trees (e.a. sets and maps (unordered and ordered)), Graph

    * Modified heuristic function for A* to follow the tail of the snake, has
      not been as effective as desired
    * Idea to modify the heurisitic function for the search to weight nodes by
      the number of reachable squares from that location in the graph (e.a. size
      of graph component), ideally the graph will always be single component
      which would eradicate the purpose of the heuristic function
    * Implemented DFS search with minimal success, the search traps itself often,
      but is blazingly fast, might be able to leverage this type of search with
      modifications to generate an approximation of a Hamaltonian Circuit
      throughout the graph
    * Idea to remove nodes from the graph as I visit them until all nodes are
      removed, the order in which the nodes are removed is an approximation of a
      Hamaltonian Circuit


April 21:

 * * * * * * * * * * * * * * * * * * * *
 * Average Scores using AStar with     *
 *     modified heuristic              *
 *                                     *
 * Size: 20 x 20                       *
 * Number Items : 100                  *
 * Average Score: 62.24                *
 * Maximum Score: 100                  *
 * Average Time : 0.0015239223         *
 *                                     *
 * * * * * * * * * * * * * * * * * * * *

 * * * * * * * * * * * * * * * * * * * *
 * Average Scores using DFS SSSP       *
 *                                     *
 * Size: 20 x 20                       *
 * Number Items : 100                  *
 * Average Score: 43.34                *
 * Maximum Score: 54                   *
 * Average Time : 1.11068321e-05       *
 *                                     *
 * * * * * * * * * * * * * * * * * * * *

    * The modified heuristic A* has performed much better than current
      implementation of the genetic algorithm or the DFS search as shown above
    * Added GitLab runner provided by Devon Schneider with attribution
    * The GitLab runner enhances testing by ensuring all put_backs meet standard
      and should protect the runner scripts
    * Runner tests successful compilation on master when pushing to repo -
      ensures proper software development practices are being upheld (e.a. not
      inducing crashing/hanging on the runner scripts)

April 22:
    * Idea to genereate/locate a path from the food to the tail after locating
      and executing a path from the head to the food

April 23:
    * Implemented the idea from April 22, success has been the same as the A*
      with modified heuristic thus far, even with path compression which did not
      appear to improve anything (with respect to the scores)
    * Success was minimal with the continual search approach because the snake
      split the graph into multiple components a number of times
    * The snake finds paths effectively and what appears to be a cycle begins to
      develop from the snake's head around to the snake's tail, but the snake
      continues to trap itelf
    * Idea to turn into larger component when pathfinding... implementation is
      the challenge here -> size of componenet can easily be known with a bfs,
      and a path to all elements can easily be known, but how to decide when to
      turn towards the larger component... look ahead?

      Testing: Various Size Boards (Visual), 100 Run Script, Scoreboard
      Data Structures: Sets, Maps, Hashes, Heaps, RB Trees, arrays, Graphs

April 24:
    * Updated for random searching in A* Cycle Algorithm if no path is found ->
      appears to have improved the scores (graphically)
    * scoreboard confirms my suspicion of this improvement in average/max score
    * Testing: Track minimum score
    * Idea to implement searching algorithm to search to the tail of the snake,
      then execute the moves along the path and search from that location to the
      food, then to search from the food to the head of the snake, this should
      ensure the snake can always find a path from the head to the tail
    * Just a few thoughts: I think the algorithm listed above will perform
      optimally because the path to the tail is critical, and when the snake
      loses a path to it's tail it traps itself.
    * Implementation of the above algorithm was much less effective than
      origionally desired. I am going to go to bed as it is 4 A.M. and my
      algorithm was unsuccessful.

    * Testing and Data Structures remain constant

April 25:
    * Five hours of sleep later I have expanded my idea -> I need to follow the
      tail when I can not get to the food or back to the tail from the food,
      This is how I will ensure I always have a path to my tail to allow the
      cycle to develop and prevent from trapping myself
    * I think my idea (above) about requiring a path to the tail was correct,
      my implementation was incorrect: finding path to the tail before and after
      eating the food does not ensure that there path to the tail will always
      exist because in my implementation as long as 1/3 of those paths existed
      the snake would move as if all was swell not knowing it was walking right
      into it's own death
    * Tracking that all paths are found (path to food, path to tail) before
      deciding to follow the tail is critical
    * FINALLY I GOT IT TO WORK! MY IDEA WAS CORRECT!! IT DEVELOPS A CYCLE!!!
    * Implementation was much easier for this one than the previous algorithms
      besides some extra tail management
    * Added GetTail and HasObstacles member retrieval functions to the playfield
      class to reduce debug time
    * Implemented the execution of moves from the head to the food in the
      algorithm above by leveraging playfield code to create a simulation (which
      essentailly a playfield with an identical interface but can me manipulated
      by my objects as friends)
    * Planning to search for optomizations to the algorithm, document code, and
      test the player

    * Testing and Data Structures remain constant

April 26:
    * Given my success yesterday the player has performed incredible. The player
      has runs which never end (infinte) because the player will never elect to
      kill iteself, this also causes the code to hang at time when the snake is
      forced to eat an apple in it's path, but does not want to grow any longer
      so that the snake does not kill itself
    * Idea: I think if I searched to every empty space
      at that point to increase distance between tail and head the player would
      win everytime on the playfield with no obstacles - e.a. perfect score is
      always acheivable (with enough moves and logic...)
    * Must manage own tail - eradicate (Playfield::getTail())
    * Updated to not use a modified interface, and game.cpp kills infinite games
      when the number of moves without eating an apple exceeds the 10 * number of
      spots in the grid
    * Evidently the Cyclic A* Search player outperforms all of my previous
      players by orders of magnitude and could be adapted to be optimal
      Data Structures: Graph, Queue, Linked List, Array
      Testing: 100 runs script, GitLab Runner, visually tested unique board sizes
      like 3x50
    * Cyclic A* Seaching Algorithm performs very well on all variations of board
      sizes + with or w/o obstacles
    * Does caching the path affect the performance? No, because the location of
      the snake tail is always accounted for (e.a. as long as a path to the tail
      exists you are good to go) - caching is faster
    * Documented and cleand the code while focussing on writing object oriented,
      modular code
    * The new game file prevents infinite runs and allows for testing (thank you)

*********************************************************************************Insert 20x20 100 run scores

April 28:
    * Code is loosly coupled, and minimal
    * Code is well documented and tested
    * README with description of the algorithm is written

April 29:
    * Wrote a script to test unique/regular board sizes (3x50), etc. - Dramatic
      improvement to the testing

*********************************************************************************Insert all scores here

    * added performance to README
    * full documentation code which is written to be self-describing and
      self-documenting. The code reads like well-written prose.
    * Everything is an object with dependency injection as the design pattern

      Objects: Heurisitic, Cycle, Graph, A*, Player, Simulation, Simulatefield

    * removed heuristic ^

April 30:
    * added GIFS of graphical player with and without obstacles to README
    * added link to Log and development to README
    * Idea to implement the perfect player by creating tail buffer where all open
      nodes are added to the buffer between the head and tail once the player
      begins to loop infintely this will ensure the food can always be eaten (in
      most cases) - better description of algorithm listed above
    * Fixed code hanging when apple is placed in the simulation where the apple
      is between the head and the path to the tail, preventing the snake from
      executing any valid move without killing itself
    * The fix was to not place apples in the simuation in the moveHead() routine
    * code has been tested 1000 runs at a time with the upgraded script to
      include assorted size boards to analyzing performance of a specific
      improvement at a detailed level
    * Used Valgrind to detect memory leaks, and found the start-up code does not
      delete the game in the driver, added delete game, and found there were no
      memory leaks - This was a big win for my snake (and my ability to write 
      clean professional software)

      Testing: Test Script 1000+ runs, GitLab Runner, Scoreboard, Visual
      Data Structures: Same - Very Object Oriented Programming

May 1:
    * created better GIFS with more exciting runs
    * add obstacle performance to README
    * created a performance breakdown to detail the performance of the player on
      assorted boards
    * upgraded the run script for detailed output direct to the performance
      breakdown
    * read the code base
    * cleaned up old branches in the repo
    * reorganized the directory structure to ressemble a professional project
    * attempted to write 'perfect player' which creates the buffer between the
      head and tail when the snake stops progressing in the game, but with little
      success.
    * Code is tested, examined for memory leaks, run 1000's of times on assorted
      game boards, and documented - Green Light
